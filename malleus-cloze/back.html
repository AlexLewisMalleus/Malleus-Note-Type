<div class="clozefield" id="text">{{cloze:Text}}</div>

<!-- Randomisation -->
<script>
function generateSeededRandom() {
    const now = new Date();
    const seed = `${now.getFullYear()}${String(now.getMonth()).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}`;
    let hash = 0;
    for (let i = 0; i < seed.length; i++) {
        hash = ((hash << 5) - hash) + seed.charCodeAt(i);
        hash = hash & hash;
    }
    return () => {
        hash = (hash * 9301 + 49297) % 233280;
        return hash / 233280;
    };
}

function processContent() {
    const content = document.getElementById('text');
    let processedText = content.innerHTML;
    
    // Extract target score from [score:X] or [score:X,Y] or [showscore:X] or [showscore:X,Y] patterns
    let targetScore = null;
    let targetScoreMax = null;
    let showScore = false;

    // Handle score ranges and visibility
    processedText = processedText.replace(/\[(show)?score:(\d+)(?:,(\d+))?\]/g, (match, show, min, max) => {
        targetScore = parseInt(min);
        targetScoreMax = max ? parseInt(max) : targetScore;
        showScore = !!show;
        
        // If it's a range, randomly select a target
        if (targetScore !== null && targetScoreMax !== null && targetScore !== targetScoreMax) {
            const random = generateSeededRandom();
            targetScore = Math.floor(targetScore + random() * (targetScoreMax - targetScore + 1));
        }
        
        // Return the actual target score if showScore is true
        if (showScore) {
            return `${targetScore}`;
        }
        return ''; // Remove the score text if not showing
    });
    
    const random = generateSeededRandom();
    let currentScore = 0;
    let remainingTargetScore = targetScore;
    
    const scoredListCount = (processedText.match(/\[scoredlist:/g) || []).length;
    const scoredNumberCount = (processedText.match(/\[scorednumber:/g) || []).length;
    const totalScoredElements = scoredListCount + scoredNumberCount;
    let processedElements = 0;

    processedText = processedText.replace(
        /\[random:([-\d.]+),([-\d.]+):(\d+)\]/g,
        (match, min, max, decimals) => {
            const minNum = parseFloat(min);
            const maxNum = parseFloat(max);
            const value = minNum + random() * (maxNum - minNum);
            return value.toFixed(parseInt(decimals));
        }
    );

    processedText = processedText.replace(
        /\[random:([-\d.]+),([-\d.]+),(\d+)\]/g,
        (match, min, max, decimals) => {
            const minNum = parseFloat(min);
            const maxNum = parseFloat(max);
            const value = minNum + random() * (maxNum - minNum);
            return value.toFixed(parseInt(decimals));
        }
    );

    processedText = processedText.replace(
        /\[list:([^\]]+)\]/g,
        (match, items) => {
            const options = items.split(',').map(item => item.trim());
            const index = Math.floor(random() * options.length);
            return options[index];
        }
    );

    processedText = processedText.replace(
        /\[scoredlist:([^\]]+)\]/g,
        (match, items) => {
            processedElements++;
            const options = items.split(',').map(item => {
                const [text, score] = item.split(':').map(s => s.trim());
                return { text, score: parseInt(score) };
            });

            if (targetScore !== null) {
                const remainingElements = totalScoredElements - processedElements;
                const minRemainingPossibleScore = 0;
                const maxRemainingPossibleScore = remainingElements;

                const idealScore = Math.round(remainingTargetScore / (remainingElements + 1));

                const validOptions = options.filter(opt => {
                    const possibleRemainingScore = remainingTargetScore - opt.score;
                    return possibleRemainingScore >= minRemainingPossibleScore &&
                           possibleRemainingScore <= maxRemainingPossibleScore;
                });

                if (validOptions.length === 0) {
                    const fallbackOptions = options.filter(opt => opt.score <= remainingTargetScore);
                    if (fallbackOptions.length === 0) return options[0].text;
                    const selected = fallbackOptions[Math.floor(random() * fallbackOptions.length)];
                    currentScore += selected.score;
                    remainingTargetScore -= selected.score;
                    return selected.text;
                }

                const bestOptions = validOptions.sort((a, b) =>
                    Math.abs(a.score - idealScore) - Math.abs(b.score - idealScore)
                );

                const selected = bestOptions[Math.floor(random() * Math.min(2, bestOptions.length))];
                currentScore += selected.score;
                remainingTargetScore -= selected.score;
                return selected.text;
            } else {
                const index = Math.floor(random() * options.length);
                const selected = options[index];
                currentScore += selected.score;
                return selected.text;
            }
        }
    );

    processedText = processedText.replace(
        /\[scorednumber:([-\d.,]+):(\d+):([-\d.,]+)\]/g,
        (match, ranges, decimals, scores) => {
            processedElements++;
            const rangeValues = ranges.split(',').map(v => parseFloat(v));
            const scoreValues = scores.split(',').map(s => parseInt(s));
            const decimalPoints = parseInt(decimals);

            if (rangeValues.length !== scoreValues.length + 1) {
                console.error('Mismatch between ranges and scores');
                return 'ERROR';
            }

            if (targetScore !== null) {
                const remainingElements = totalScoredElements - processedElements;
                const idealScore = Math.round(remainingTargetScore / (remainingElements + 1));

                let bestScoreIndex = 0;
                let minDiff = Math.abs(scoreValues[0] - idealScore);
                for (let i = 1; i < scoreValues.length; i++) {
                    const diff = Math.abs(scoreValues[i] - idealScore);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestScoreIndex = i;
                    }
                }

                const rangeMin = rangeValues[bestScoreIndex];
                const rangeMax = rangeValues[bestScoreIndex + 1];
                const value = rangeMin + random() * (rangeMax - rangeMin);
                currentScore += scoreValues[bestScoreIndex];
                remainingTargetScore -= scoreValues[bestScoreIndex];
                return value.toFixed(decimalPoints);
            } else {
                const value = rangeValues[0] + random() * (rangeValues[rangeValues.length - 1] - rangeValues[0]);

                for (let i = 0; i < rangeValues.length - 1; i++) {
                    if (value >= rangeValues[i] && value < rangeValues[i + 1]) {
                        currentScore += scoreValues[i];
                        return value.toFixed(decimalPoints);
                    }
                }

                currentScore += scoreValues[scoreValues.length - 1];
                return value.toFixed(decimalPoints);
            }
        }
    );

    processedText = processedText.replace(
        /\[scorednumber:([-\d.]+),([-\d.]+),([-\d.]+):([-\d.]+),([-\d.]+)\]/g,
        (match, min, max, threshold, score1, score2) => {
            processedElements++;
            const minNum = parseFloat(min);
            const maxNum = parseFloat(max);
            const thresholdNum = parseFloat(threshold);
            const score1Num = parseFloat(score1);
            const score2Num = parseFloat(score2);

            if (targetScore !== null) {
                const remainingElements = totalScoredElements - processedElements;
                const idealScore = Math.round(remainingTargetScore / (remainingElements + 1));

                let value;
                if (Math.abs(score1Num - idealScore) < Math.abs(score2Num - idealScore)) {
                    value = minNum + random() * (thresholdNum - minNum);
                    currentScore += score1Num;
                    remainingTargetScore -= score1Num;
                } else {
                    value = thresholdNum + random() * (maxNum - thresholdNum);
                    currentScore += score2Num;
                    remainingTargetScore -= score2Num;
                }

                return value.toFixed(1);
            } else {
                const value = minNum + random() * (maxNum - minNum);
                if (value < thresholdNum) {
                    currentScore += score1Num;
                } else {
                    currentScore += score2Num;
                }
                return value.toFixed(1);
            }
        }
    );

    content.innerHTML = processedText;
}

processContent();
</script>

<script>
  // ##############  HINT REVEAL SHORTCUTS  ##############
  // All shortcuts will also open with "H" if using the Hint Hotkeys add-on 
  var ButtonShortcuts = {
      "Personal Notes" : "Alt+1",
      "Missed Questions" : "Alt+2",
      "Oxford Handbook" : "Alt+3",
      "AMBOSS" : "Alt+4",
      "First Aid" : "Alt+5",
      "eTG Complete" : "Alt+6",
      "Talley & O'Connor" : "Alt+7",
      "Additional Resources" : "Alt+8",
      "Source" : "Alt+9",
  }

  var ToggleAllButtonsShortcut = "'"
  var ToggleNextButtonShortcut = "H";
  // ##############  SHOW HINTS AUTOMATICALLY  ##############
  var ButtonAutoReveal = {
      "Personal Notes" : true,
      "Missed Questions" : false,
      "Oxford Handbook" : false,
      "AMBOSS" : false,
      "First Aid" : false,
      "eTG Complete" : false,
      "Talley & O'Connor" : false,
      "Additional Resources" : false,
      "Source" : false,
  }

  var ScrollToButton = true;

  // ##############  TAG SHORTCUT  ##############
  var toggleTagsShortcut = "C";

  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND
  var tagID = "XXXYYYZZZ"

  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN
  // -1 to show tags without "Malleus_CM::" at the beginning
  var numTagLevelsToShow = -1;
</script>

<!-- BUTTON FIELDS -->
{{#Personal Notes}}
<span id = "hint-pn" class="hintBtn" data-name="Personal Notes">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-pn')"></a>
  <button id="button-pn" class="button-general" onclick="toggleHintBtn('hint-pn')">
    <img src="_Anking_v3.png"> Personal Notes
  </button>
  <div id="notes" class="hints" style="display: none;">{{edit:Personal Notes}}</div>
</span>
{{/Personal Notes}}

{{#Missed Questions}}
<span id = "hint-mq" class="hintBtn" data-name="Missed Questions">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-mq')"></a>
  <button id="button-mq" class="button-general" onclick="toggleHintBtn('hint-mq')">
    <img src="_Anking_v3.png"> Missed Questions
  </button>
  <div id="missed" class="hints" style="display: none;">{{edit:Missed Questions}}</div>
</span>
{{/Missed Questions}}

<!-- Extra field -->
{{#Extra}}<p></p>
<div id="extra">{{edit:Extra}}</div>
<br>{{/Extra}}

{{#Oxford Handbook}}
<span id = "hint-oxhbk" class="hintBtn" data-name="Oxford Handbook">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-oxhbk')"></a>
  <button id="button-oxhbk" class="button-general" onclick="toggleHintBtn('hint-oxhbk')">
    <img src="oxford_handbook_clinical_medicine_12x9px.jpg"> Oxford Handbook
  </button>
  <div id="oxhbk" class="hints" style="display: none;">{{edit:Oxford Handbook}}</div>
</span>
{{/Oxford Handbook}}

{{#AMBOSS}}
<span id = "hint-amboss" class="hintBtn" data-name="AMBOSS">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-amboss')"></a>
  <button id="button-amboss" class="button-general" onclick="toggleHintBtn('hint-amboss')">
    <img src="AMBOSS_Logo_12x12px_v2.png"> AMBOSS
  </button>
  <div id="amboss" class="hints" style="display: none;">{{edit:AMBOSS}}</div>
</span>
{{/AMBOSS}}


{{#First Aid}}
<span id = "hint-fa" class="hintBtn" data-name="First Aid">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-fa')"></a>
  <button id="button-fa" class="button-general" onclick="toggleHintBtn('hint-fa')">
    <img src="_first-aid.icon_v2.1.png"> First Aid
  </button>
  <div id="firstaid" class="hints" style="display: none;">{{edit:First Aid}}</div>
</span>
{{/First Aid}}


{{#eTG Complete}}
<span id = "hint-etg" class="hintBtn" data-name="eTG Complete">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-etg')"></a>
  <button id="button-etg" class="button-general" onclick="toggleHintBtn('hint-etg')">
    <img src="eTG_12x12px.png"> eTG Complete
  </button>
  <div id="etg" class="hints" style="display: none;">{{edit:eTG Complete}}</div>
</span>
{{/eTG Complete}}

{{#Talley & O'Connor}}
<span id = "hint-toc" class="hintBtn" data-name="Talley & O'Connor">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-toc')"></a>
  <button id="button-toc" class="button-general" onclick="toggleHintBtn('hint-toc')">
    <img src="talley_12x9px.jpg"> Talley & O'Connor
  </button>
  <div id="toc" class="hints" style="display: none;">{{edit:Talley & O'Connor}}</div>
</span>
{{/Talley & O'Connor}}


{{#Additional Resources}}
<span id = "hint-ar" class="hintBtn" data-name="Additional Resources">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-ar')"></a>
  <button id="button-ar" class="button-general" onclick="toggleHintBtn('hint-ar')">
    <img src="_Anking_v3.png"> Additional Resources
  </button>
  <div id="additional" class="hints" style="display: none;">{{edit:Additional Resources}}</div>
</span>
{{/Additional Resources}}

{{#Source}}
<span id = "hint-source" class="hintBtn" data-name="Source">
  <a href="#" class="hint" onclick="toggleHintBtn('hint-source')"></a>
  <button id="button-source" class="button-general" onclick="toggleHintBtn('hint-source')">
    <img src="_Anking_v3.png"> Source
  </button>
  <div id="source" class="hints" style="display: none;">{{edit:Source}}</div>
</span>
{{/Source}}

<!-- NOT-PERSISTING EVENT LISTENER -->
<script>
  if (window.ankingEventListeners) {
      for (const listener of ankingEventListeners) {
          const type = listener[0]
          const handler = listener[1]
  document.removeEventListener(type, handler)
  }
  }
  window.ankingEventListeners = []

  window.ankingAddEventListener = function(type, handler) {
  document.addEventListener(type, handler)
  window.ankingEventListeners.push([type, handler])
  }
</script>

<!-- Shortcut Matcher Function -->
<script>
  var specialCharCodes = {
      "-": "minus",
      "=": "equal",
      "[": "bracketleft",
      "]": "bracketright",
      ";": "semicolon",
      "'": "quote",
      "`": "backquote",
      "\\": "backslash",
      ",": "comma",
      ".": "period",
      "/": "slash",
  };
  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
  let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())
    let mainKey = shortcutKeys[shortcutKeys.length - 1]
    if (mainKey.length === 1) {
    if (/\d/.test(mainKey)) {
    mainKey = "digit" + mainKey
    } else if (/[a-zA-Z]/.test(mainKey)) {
    mainKey = "key" + mainKey
    } else {
    let code = specialCharCodes[mainKey];
    if (code) {
    mainKey = code
    }
    }
    }
    let ctrl = shortcutKeys.includes("ctrl")
    let shift = shortcutKeys.includes("shift")
    let alt = shortcutKeys.includes("alt")

    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {
    if (mainKey !== event.code.toLowerCase()) return false
    if (ctrl !== (event.ctrlKey || event.metaKey)) return false
    if (shift !== event.shiftKey) return false
    if (alt !== event.altKey) return false
    return true
    }.bind(window, ctrl, shift, alt, mainKey)

    return matchShortcut
    }
</script>

<!-- HINT BUTTONS SETUP -->
<script>
  (function() {
      window.toggleHintBtn = function(containerId, noScrolling=false) {
          const container = document.getElementById(containerId)
          const link = container.getElementsByTagName("a")[0]
          const button = container.getElementsByTagName("button")[0]
          const hint = container.getElementsByTagName("div")[0]

          if (hint.style.display == "none") {
              button.classList.add("expanded-button")
  hint.style.display = "block"
  link.style.display = "none"
  if (ScrollToButton && !noScrolling) {
  hint.scrollIntoView({
  behavior: "smooth", // "auto" for instant scrolling
  block: "start",
  inline: "nearest"
  });
  }
  } else {
  button.classList.remove("expanded-button")
  hint.style.display = "none"
  link.style.display = ""
  }
  }

  window.toggleNextButton = function(){
  // adapted from Hint Hotkey add-on
  var customEvent = document.createEvent('MouseEvents');
  customEvent.initEvent('click', false, true);
  var arr = document.getElementsByTagName('a');
  for (var i=0; i<arr.length; i++) {
                              var el = arr[i];
                              if (el.style.display === 'none') {
                              continue;
                              }
                              if (el.classList.contains("hint")) {
                              el.dispatchEvent(customEvent);
                              break
                              }
                              }
                              }

                              const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)
                              ankingAddEventListener("keydown", (evt) => {
    if (evt.repeat) return
    if (isToggleNextShortcut(evt)) {
    toggleNextButton()
    }
    })

    const setupHintBtn = function(elem) {
    const containerId = elem.id
    const fieldName = elem.dataset.name
    const button = elem.getElementsByClassName("button")[0]

    if (ButtonAutoReveal[fieldName]) {
    toggleHintBtn(containerId, noScrolling=true)
    }

    const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])
    const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)
    ankingAddEventListener("keydown", (evt) => {
    if (evt.repeat) return
    if (isShortcut(evt) || isToggleAllShortcut(evt)) {
    toggleHintBtn(containerId)
    }
    })
    }

    const hints = document.getElementsByClassName("hintBtn")
    for (let i = 0; i < hints.length; i++) {
                        setupHintBtn(hints[i])
                        }
                        })()
                        </script>

<!-- CLICKABLE COLORFUL TAGS -->
{{#Tags}}
<div id="tags-container">{{clickable::Tags}}</div>
<script>
  var tagContainer = document.getElementById("tags-container")
  if (tagContainer.childElementCount == 0) {
      var tagList = tagContainer.innerHTML.split(" ");
      var kbdList = [];
      var newTagContent = document.createElement("div");

      for (var i = 0; i < tagList.length; i++) {
          var newTag = document.createElement("kbd");
          var tag = tagList[i];
  // numTagLevelsToShow == 0 means the whole tag should be shown
  if(numTagLevelsToShow != 0){
  tag = tag.split('::').slice(-numTagLevelsToShow).join("::");
  }
  newTag.innerHTML = tag;
  newTagContent.append(newTag)
  }
  tagContainer.innerHTML = newTagContent.innerHTML;
  tagContainer.style.cursor = "default";
  }
  if (tagContainer.innerHTML.indexOf(tagID) != -1) {
  tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
  }

  function showtags() {
  var tagContainerShortcut = document.getElementById("tags-container");

  if (tagContainerShortcut.style.display
  === "none") {
  tagContainerShortcut.style.display = "block";
  } else {
  tagContainerShortcut.style.display =
  "none";
  }
  }

  var isShortcut = shortcutMatcher(toggleTagsShortcut)
  ankingAddEventListener('keyup', function (e) {
  if (isShortcut(e)) {
  showtags();
  }
  });

</script>
{{/Tags}}
